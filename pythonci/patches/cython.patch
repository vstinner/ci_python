commit cffbc5c417a55cfb17ff5201aa63b5269e94ba61
Author: Victor Stinner <vstinner@python.org>
Date:   Tue May 26 17:40:17 2020 +0200

    WIP: Use Py_SET_SIZE() on Python 3.9.0a4 and newer

diff --git a/Cython/Utility/Builtins.c b/Cython/Utility/Builtins.c
index 27a551213..7d0596965 100644
--- a/Cython/Utility/Builtins.c
+++ b/Cython/Utility/Builtins.c
@@ -279,7 +279,11 @@ static PyObject *__Pyx_PyLong_AbsNeg(PyObject *n) {
     {
         PyObject *copy = _PyLong_Copy((PyLongObject*)n);
         if (likely(copy)) {
+#if PY_VERSION_HEX >= 0x030900A4
+            Py_SET_SIZE(copy, -Py_SIZE(copy));
+#else
             Py_SIZE(copy) = -(Py_SIZE(copy));
+#endif
         }
         return copy;
     }
diff --git a/Cython/Utility/Optimize.c b/Cython/Utility/Optimize.c
index d6c32ace2..a25c95744 100644
--- a/Cython/Utility/Optimize.c
+++ b/Cython/Utility/Optimize.c
@@ -35,7 +35,11 @@ static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
     if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
         Py_INCREF(x);
         PyList_SET_ITEM(list, len, x);
+#if PY_VERSION_HEX >= 0x030900A4
+        Py_SET_SIZE(list, len+1);
+#else
         Py_SIZE(list) = len+1;
+#endif
         return 0;
     }
     return PyList_Append(list, x);
@@ -53,7 +57,11 @@ static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
     if (likely(L->allocated > len)) {
         Py_INCREF(x);
         PyList_SET_ITEM(list, len, x);
+#if PY_VERSION_HEX >= 0x030900A4
+        Py_SET_SIZE(list, len+1);
+#else
         Py_SIZE(list) = len+1;
+#endif
         return 0;
     }
     return PyList_Append(list, x);
@@ -104,7 +112,11 @@ static CYTHON_INLINE PyObject* __Pyx__PyObject_Pop(PyObject* L) {
 static CYTHON_INLINE PyObject* __Pyx_PyList_Pop(PyObject* L) {
     /* Check that both the size is positive and no reallocation shrinking needs to be done. */
     if (likely(PyList_GET_SIZE(L) > (((PyListObject*)L)->allocated >> 1))) {
+#if PY_VERSION_HEX >= 0x030900A4
+        Py_SET_SIZE(L, Py_SIZE(L) - 1);
+#else
         Py_SIZE(L) -= 1;
+#endif
         return PyList_GET_ITEM(L, PyList_GET_SIZE(L));
     }
     return CALL_UNBOUND_METHOD(PyList_Type, "pop", L);
@@ -167,7 +179,11 @@ static PyObject* __Pyx__PyList_PopIndex(PyObject* L, PyObject* py_ix, Py_ssize_t
         }
         if (likely(__Pyx_is_valid_index(cix, size))) {
             PyObject* v = PyList_GET_ITEM(L, cix);
+#if PY_VERSION_HEX >= 0x030900A4
+            Py_SET_SIZE(L, Py_SIZE(L) - 1);
+#else
             Py_SIZE(L) -= 1;
+#endif
             size -= 1;
             memmove(&PyList_GET_ITEM(L, cix), &PyList_GET_ITEM(L, cix+1), (size_t)(size-cix)*sizeof(PyObject*));
             return v;
diff --git a/tests/run/verbatiminclude.pyx b/tests/run/verbatiminclude.pyx
index bb2728586..6cc0fdf41 100644
--- a/tests/run/verbatiminclude.pyx
+++ b/tests/run/verbatiminclude.pyx
@@ -25,9 +25,9 @@ cdef class C:
 
 cdef extern from "Python.h":
     """
-    #define Py_SET_SIZE(obj, size)  Py_SIZE((obj)) = (size)
+    #define my_SET_SIZE(obj, size)  Py_SIZE((obj)) = (size)
     """
-    void Py_SET_SIZE(object, Py_ssize_t)
+    void my_SET_SIZE(object, Py_ssize_t)
 
 
 def test_square(x):
@@ -59,4 +59,4 @@ def test_class():
 def test_set_size(x, size):
     # This function manipulates Python objects in a bad way, so we
     # do not call it. The real test is that it compiles.
-    Py_SET_SIZE(x, size)
+    my_SET_SIZE(x, size)
